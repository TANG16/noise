% Monte Carlo simulation of AR(p) spectra with parameters fit to time
% series. Make sure that if the time series is not unit variance to
% specify the variance, or else the confidence intervals will not have the 
% appropriate magnitude.
%
% IN:
% a: lag autocorrelation coefficient(s), number of coefficients is order
%   of autoregressive process
% e: innovations variance
% 'var': target variance for time series generated by the process (by
%   default not enforced)
% 'conf': confidence intervals to evaluate at, can be a vector. Percents, 
%   not decimals, (default 95)
% 'ntrial': number of monte carlo trials (default 1000)
% 'nsample': number of data points for simulated time series (default
%   1000)
% 'dt': sample spacing
% 'estimator': 'pmtm' (default) or 'pchave'
% 'nw': time half-bandwidth product for spectral estimates (default 2)
%
% OUT:
% CI: confidence intervals
% wc: frequency axis for confidence intervals
% 
% Adrian Tasistro-Hart, adrianraph-at-gmail.com, 02.08.2018
function [CI,wc] = ARconf(a,e,varargin)

parser = inputParser;
validScalarPosNum = @(x) isnumeric(x) && isscalar(x) && (x > 0);

addRequired(parser,'a',@isnumeric);
addRequired(parser,'e',@isscalar);
addParameter(parser,'var',[],@isnumeric)
addParameter(parser,'nsample',1000,validScalarPosNum);
addParameter(parser,'ntrial',1000,validScalarPosNum);
addParameter(parser,'conf',95,@(x) all([x(:) > 0; x(:) < 100]));
addParameter(parser,'dt',1,@isscalar);
addParameter(parser,'nw',2,@isscalar);
addParameter(parser,'estimator','pmtm',@ischar);

parse(parser,a,e,varargin{:});

a      = parser.Results.a;
e      = parser.Results.e;
varnce = parser.Results.var;
n      = parser.Results.nsample;
nt     = parser.Results.ntrial;
conf   = parser.Results.conf;
dt     = parser.Results.dt;
nw     = parser.Results.nw;
est    = parser.Results.estimator;

% validate estimator
est = validatestring(est,{'pmtm','pchave'});

% create AR(p) model
arm = arima('Constant',0,'AR',a,'Variance',e);

% noise iterations
ts = simulate(arm,n,'NumPaths',nt);

% impose variance, if requested
if ~isempty(varnce)
    % first validate variance
    assert(validScalarPosNum(varnce),'variance must be positive')
    % now normalize
    ts = bsxfun(@rdivide,bsxfun(@minus,ts,mean(ts)),std(ts))*sqrt(varnce);
end

% PSDs of noise
if strcmp(est,'pmtm')
    [pxx,wc] = pmtm(ts,nw,n,1/dt);
elseif strcmp(est,'pchave')
    ts = num2cell(ts,1);
    pxx = zeros(floor(n/2)+1,nt);
    for j = 1:nt
        [pxx(:,j),wc] = pchave(ts{j},floor(n/4),80,n,1/dt,[],'dpss',nw);
    end
end

% get intervals
CI = prctile(pxx',conf);

end